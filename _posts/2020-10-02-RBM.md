---
title: Restricted Boltzmann Machine
sidebar:
  nav: docs-ko
aside:
  toc: true
key: 20201002
tags: 기계학습
---

RBM은 복잡하고 큰 그림을 보기까지 시간이 많이 걸린다.

배경으로 설명할 부분이 많기 때문이다.

왜 굳이 RBM을 공부하는가? Generative Model에 대한 이전의 생각들에 대해 짚고 넘어갈 수 있기 때문이다.

최근에는 RBM이 그다지 인기있는 모델은 아니다. 학습도 어려운데 성능도 그다지이기 때문이다. 그래도 그 아이디어만은 한번 체크해보고 가볼법하다.

# Prerequisites

RBM에 대해 잘 이해하기 위해선 다음의 내용에 대해 잘 알고 오는 것을 추천함.

* [최대우도법](https://angeloyeo.github.io/2020/07/17/MLE.html)
* [경사하강법](https://angeloyeo.github.io/2020/08/16/gradient_descent.html)
* [Rejection Sampling](https://angeloyeo.github.io/2020/09/16/rejection_sampling.html)
* [Monte Carlo Markov Chain](https://angeloyeo.github.io/2020/09/17/MCMC.html)

# 확률분포를 알 수만 있다면...

Restricted Boltzmann Machine(이하 RBM)은 Generative Model이라고 하는데, ANN, DNN, CNN, RNN 등과 같은 Deterministic Model들과 약간 다른 목표를 갖고 있다.

Deterministic Model들이 타겟과 가설 간의 차이를 줄여서 오차를 줄이는 것이 목표라고 한다면, Generative Model들의 목표는 확률밀도함수를 모델링하는 것이다.

확률 밀도 함수(probability density function, pdf)를 정확히 안다는 것은 무엇일까?

가령 얼굴을 그려주는 기계가 있다고 하자. 얼굴은 여러가지 요소로 구성되어 있는데, 가령 코를 그려준다고 해보자.

코 역시도 여러가지 다양한 가능한 경우의 형태로 구성되어 있다. 여기서 만약, 세상에 코의 형태가 동그라미, 세모, 네모 코만 있다고 가정했을 때, 

우리가 이 세가지 형태의 코에 대한 확률밀도함수를 알 수 있다고 하자. 즉, 온 세상의 얼굴에서 코의 형태를 다 조사해 histogram을 그려보았다고 해보자.

<p align = "center">
  <img width = "400" src = "https://raw.githubusercontent.com/angeloyeo/angeloyeo.github.io/master/pics/2020-10-02-RBM/pic1.png">
  <br>
  그림 1. 코의 모양에 대한 확률 분포
</p>

위의 그림을 보면 세모(▲) 모양의 코가 전 세상에서 가장 흔하다는 것을 알 수 있다.

아마 얼굴 그려주는 기계가 이런 확률 분포에 대해 알고 있다면 얼굴을 그릴 때 코에 대해서는 세모 모양의 코를 그려줄 가능성이 좀 더 높아 보인다.

이런 식으로 모든 가능한 경우에 대해 어떤 사건이 발생할 확률을 정확히 알 수 있다면, 여러 사건들의 조합으로 구성되는 사건(즉, 여기서는 전체 얼굴)을 일리있게 **생성**할 수 있게 되는 것이다.

실제로 Generative Model 중 요즘 유행하는 GAN(Generative Adversarial Networks)을 이용해 생성된 얼굴은 다음 그림에서 볼 수 있다.

<p align = "center">
  <img width = "600" src = "https://www.researchgate.net/publication/341699736/figure/fig2/AS:896007655149568@1590636280012/45-years-of-GAN-progress-on-face-generation-20147-201510-201611-201712.png">
  <br>
  그림 2. GAN을 이용해 만들어진 얼굴 변천사
  <br>
  <a href = "https://www.researchgate.net/publication/341699736_Generative_Adversarial_Networks_GANs_An_Overview_of_Theoretical_Model_Evaluation_Metrics_and_Recent_Developments"> 그림 출처 </a>
</p>

이렇듯 확률밀도함수를 통해 결과물(여기서는 얼굴)을 **생성**해주는 과정을 샘플링(sampling)이라고 한다.

즉, Generative Model의 목적은 확률분포를 정확히 학습해 좋은 sample을 sampling하는 것이라고 정리할 수 있을 것이다.

## 확률밀도함수를 학습하기 위한 머신 설계

### Boltzmann Machine

Boltzmann Machine은 이렇듯 확률분포(정확히는 확률질량함수 혹은 확률밀도함수)를 학습하기 위해 만들어졌다고 할 수 있다.

Boltzmann Machine이 가정하는 것은 "우리가 보고 있는 것들 외에도 보이지 않는 요소들까지 잘 포함시켜 학습할 수 있다면 확률분포를 좀 더 정확하게 알 수 있지 않을까?"라는 것이다.

<p align = "center">
  <img src = "https://raw.githubusercontent.com/angeloyeo/angeloyeo.github.io/master/pics/2020-10-02-RBM/pic3.png">
  <br>
  그림 3. Boltzmann Machine과 Restricted Boltzmann Machine
  <br>
  <a href = "https://www.asimovinstitute.org/neural-network-zoo/"> 그림 출처 </a>
</p>

그림 3의 왼쪽에 보이는 것이 Boltzmann Machine이고 오른쪽에 보이는 것이 Restricted Boltzmann Machine이다.

우선 Boltzmann Machine에 대해서부터 설명하자면 동그랗게 생긴 것들이 가능한 이벤트들에 대한 state이다.

가령, 이 Boltzmann Machine이 얼굴의 형태에 관한 확률밀도함수를 학습하기 위해 만들어졌고, 각 동그라미들은 얼굴의 특정 부위에 대한 상태를 표시한다고 하자.

그 중 하나의 동그라미가 코에 관한 것이고, 상태 0, 1, 2가 동그라미, 세모, 네모 모양의 코에 대한 state를 각각 나타내는 것이라고 할 수 있겠다.

Boltzmann Machine에서 또 하나 주목할 점은 노란색과 초록색으로 표현된 특성인데, 각각은 hidden unit과 visible unit의 존재를 표현한 것이다.

hidden unit이 말하는 것은 우리가 보지 못하는 어떤 특성이 존재함을 암시하고, 이것 까지도 학습할 수 있다면 좀 더 정확한 확률분포를 학습할 수 있다는 것을 전제한다.

### Restricted Boltzmann Machine

그렇다면 우리의 관심사인 Restricted Boltzmann Machine(RBM)은 뭘까?

RBM은 그림 3에서 오른쪽에 표시되어 있는데, RBM은 Boltzmann Machine에서부터 파생되어 나온 것으로 visible unit과 hidden unit에는 내부적인 연결이 없고, visible unit과 hidden unit 간의 연결만이 남아있는 형태이다.

이렇게 RBM을 구성한 것은 상당히 실용적인 이유로 사건 간의 독립성을 가정하면 확률분포의 결합을 표현하기 쉬워지기 때문이다.

쉽게 말하면 Boltzmann Machine의 계산이 너무 복잡해지니까 이를 편하게 하기 위해 덜 엄격한 모델을 구성한 것으로 볼 수 있다.

Boltzmann Machine에서 RBM과 같은 형태를 구성하게 됨으로써 생기는 독특한 점은 RBM은 **Feed-Forward Nerual Network(FFNN) 처럼 학습**하게 된다는 점이다.

뒤에 더 설명하겠지만, RBM의 작동방식은 FFNN과 유사하게 forward propagation을 통해 hidden unit의 상태를 결정하고, 다시 hidden unit의 상태로부터 back propagation을 함으로써 visible unit의 상태를 재결정하게 된다.

그렇지만 RBM을 다루면서도 잊지 않아야 할 것은 결국 RBM도 Boltzmann Machine에서부터 파생된 것으로 현상에 대한 확률분포를 학습하는 Generative Model이라는 점이다.


# RBM의 구조와 특성

위에서 서술했듯이 RBM이 무언가를 학습한다는 것은 확률분포를 습득하는 것이다.

그렇다면 RBM이 학습을 잘 했다는 것을 어떻게 수학적으로 표현할 수 있을까?

그것을 알기 위해 우선은 RBM의 구조에 대해서 조금 더 자세하게 알아보도록 하자.

## RBM의 구조

<p align = "center">
  <img src = "https://i.imgur.com/sadnLks.png">
  <br>
  그림 4. RBM의 조금 더 구체적인 구조
  <br> <a href = "https://i.imgur.com/sadnLks.png"> 그림 출처 </a>
</p>

RBM의 구조를 다시 한번 보면 visible layer와 hidden layer, 그리고 이 두 layer들을 연결해주는 weight matrix로 구성되어 있음을 알 수 있다.

거기에 더불어 visible layer와 hidden layer에는 bias term들이 포함되어 있다.

각각에 대해 설명하자면 다음과 같다.

* visible layer: 입력 데이터가 들어가는 곳. 각 입력 데이터들은 여러가지 상태(state)를 가질 수 있음. 앞으로 표기는 $v$.
* hidden layer: 은닉 데이터가 샘플링되어 나오는 곳. 각 은닉 데이터들은 여러가지 상태를 가질 수 있음. 앞으로 표기는 $h$.
* weight matrix: visible layer와 hidden layer를 연결해주는 장치. 원래의 Boltzmann Machine에서부터 파생되어 나온 개념. 앞으로 표기는 $W$.
* bias for visible layer: 입력 데이터의 내재적 특성(inherent property)을 설정해주는 부분. 후술하겠지만, 어떤 visible unit이 거의 항상 1인 경우라면 해당 unit의 bias는 높을 수록 좋음. 앞으로 표기는 $b$.
* bias for hidden layer: 은닉 데이터의 내재적 특성을 설정해주는 부분. 위의 visible layer의 bias와 유사한 역할. 앞으로 표기는 $c$.

참고로 위의 $v, h, b, c$는 모두 벡터이며 $W$는 행렬이다.

visible layer의 node 개수가 $d$개, hidden layer의 node 개수가 $n$개라고 했을 때, 각각의 차원은 다음과 같다.

$$v, b \in \Bbb{R}^{d \times 1}$$

[//]:# (식 1)

$$h, c \in \Bbb{R}^{n \times 1}$$

[//]:# (식 2)

$$W \in \Bbb{R}^{n \times d}$$

[//]:# (식 3)

이와 같은 구조를 갖는 RBM에 대해 '학습을 잘 하고 있음'을 표현해주는 것은 어떻게 가능할지 계속해서 알아보도록 하자.

## Energy: Configuration을 반영하는 수치

RBM이 학습을 잘 했다는 것을 수치적으로 판단하기 위해서는 여타 model들을 구성할 때와 마찬가지로 cost function을 정의해주어야 한다.

RBM의 cost function은 독특하게 "Energy"라는 개념을 이용해 정의되게 될텐데, 이 energy라는 개념은 물리학에서 차용한 것이라고 한다.

특정 상태 $x$에 대한 에너지를 $E(x)$라고 한다면, 이 에너지 $E(x)$는 그 상태(configuration)에 매칭되는 값임을 말한다.

즉, 상태 $x$에 대한 사건들의 분포를 말해주기도 하므로, 이는 확률분포와 연결시켜 생각할 수 있다.

다항분포로부터 가능한 모든 경우의 $x$에 대한 energy 함수 중, 우리가 원하는 $x$에 대한 에너지를 얻을 확률을 계산하면 다음과 같이 특정 상태 $x$에 대한 확률값을 계산할 수 있게 된다.

$$p(x) = \frac{\exp(-E(x))}{Z}$$

[//]:# (식 4)

$$\text{where }Z=\sum_x\exp(-E(x))$$

[//]:# (식 5)

그런데, 우리는 RBM에서 visible units $v$와 hidden units $h$의 상태에 따라 에너지를 결정할 수 있게 되는데, 결국 우리가 관찰할 수 있는 것은 visible units $v$에 의한 energy 이므로 다음과 같이 visible units의 확률 분포를 결정할 수 있다.

$$p(v) = \sum_h p(v, h) = \sum_h \frac{\exp(-E(v, h))}{Z}$$

[//]:# (식 6)

$$\text{where }Z = \sum_v \sum_h \exp(-E(v,h))$$

[//]:# (식 7)

여기서 hidden units에 대한 개념을 도입하다보니 식 (4)가 식 (6)처럼 복잡해졌기 때문에 다음과 같이 치환해 식(6)을 식(4)처럼 만들어주도록 하자.

$$식(6) \Rightarrow p(v) = \frac{\exp(-F(v))}{Z'}$$

[//]:# (식 8)

$$\text{where }F(v) = -\log\sum_h\exp(-E(v,h))$$

[//]:# (식 9)

$$\text{ and } Z' = \sum_v\exp(-F(v))$$

[//]:# (식 10)

여기서 $F(\cdot)$을 Free Energy라고 이름 붙이도록 하자.

한편, RBM에서 Energy는 다음과 같이 정의한다.

$$E(v,h) = -b'v - c'h - h'Wv$$

[//]:# (식 11)

여기서 $'$ 표시는 전치(transpose)이다. 

RBM은 에너지를 식 (11)과 같이 정의했을까? 그것은 $b, c, W$에 관한 설명을 통해 확인할 수 있는데, 특히 $b$와 $c$는 visible layer와 hidden layer의 bias term으로 visible layer의 내재적 특성과 hidden layer의 내재적 특성을 설정한다고 설명한 바 있다.

즉, 주어지는 데이터의 특서에 맞게 이 bias term들이 변형되어야 한다. 이 bias term들은 특정 visible unit 혹은 hidden unit이 얼마나 자주 "ON" 상태가 되어있는지에 따라 값이 커지도록 설정될 것이다. 어떤 visible unit이 거의 항상 1인 경우라면 해당 unit의 bias는 높을 수록 식 (11)에서 에너지 값이 떨어지고 낮은 에너지는 안정적인 상태를 의미한다.

## 두 가지의 상태만 갖는 RBM

많은 RBM의 연구에서 visible unit 혹은 hidden unit은 0 또는 1의 상태만 갖는 RBM을 다룬다.

Free Energy 수식 유도

$$식(9)\Rightarrow -\log\sum_h\exp(-(-b'v-c'h-h'Wv))$$

$$=-\log\sum_h\exp(b'v+c'h+h'Wv)$$

$$=-\log\sum_h \exp(b'v)\exp(c'h+h'Wv)$$

$$=-\log\exp(b'v)\sum_h\exp(c'h+h'Wv)$$

$$=-b'v - \log\sum_h\exp(c'h+h'Wv)$$

여기서 $h\in{0, 1}$ 이므로,

$$=-b'v-\sum_{i=1}^n\log(\exp(0)+\exp(c_i+W_iv))$$

$$=-b'v-\sum_{i=1}^n\log(1+\exp(c_i+W_iv))$$

여기서 $W_i$는 $W$의 $i$번째 행으로 부터 얻은 행벡터를 의미함.

조건부 확률 수식 유도

$$p(h|v) = \frac{p(h,v)}{p(v)}=\frac{\frac{1}{Z}\exp(-E(h,v))}{\sum_h p(h,v)}$$

$$=\frac{\frac{1}{Z}\exp(-E(h,v))}{\sum_h \frac{1}{Z}\exp(-E(h,v))}$$

$$=\frac{\exp(-E(h,v))}{\sum_h \exp(-E(h,v))}$$

$$=\frac{\exp(b'v+c'h+h'Wv)}{\sum_h\exp(b'v+c'h+h'Wv)}$$

$$=\frac{\exp(b'v)\exp(c'h+h'Wv)}{\sum_h\exp(b'v)\exp(c'h+h'Wv)}$$

$$=\frac{\exp(b'v)\exp(c'h+h'Wv)}{\exp(b'v)\sum_h\exp(c'h+h'Wv)}$$

$$=\frac{\exp(c'h+h'Wv)}{\sum_h\exp(c'h+h'Wv)}$$

여기서 $p(h_i=1\|v)$를 계산하자.

$h\in\lbrace 0, 1\rbrace$ 이므로,

$$p(h_i=1|v)=\frac{\exp(c_i+W_iv)}{\sum_h\exp(c_ih_i+h_iW_iv)}$$

$$=\frac{\exp(c_i+W_iv)}{\exp(0)+\exp(c_i+W_iv)}$$

$$=\frac{\exp(c_i+W_iv)}{1+\exp(c_i+W_iv)}$$

$$=\frac{1}{1+1/\exp(c_i+W_iv)}$$

$$=\sigma(c_i+W_iv)$$

여기서 $\sigma(\cdot)$은 sigmoid 함수이다.

마찬가지 방법으로

$$p(v_j = 1|h) = \sigma(b_j + W_j'h)$$

이다.

$W_j'$은 $W$ 행렬의 $j$번재 열로부터 얻은 행벡터를 의미함.

# RBM의 학습 과정

## Gradient Descent를 이용한 RBM의 학습

RBM의 파라미터들($b, c, W$)이 잘 학습되었다면 현재 데이터들을 가지고 얻은 모든 likelihood의 곱이 최대가 될 것이다.

(이 문장이 이해가 안된다면 꼭 [최대우도법](https://angeloyeo.github.io/2020/07/17/MLE.html) 편을 공부하고 오는 것을 추천한다!)

다시 말해, 우리는 식 (8)에서 visible layer를 통해서 확인할 수 있는 확률에 대해 정의한 바 있는데  우리가 RBM의 파라미터들을 잘 학습하기 위해서는 결국 식 (8)의 확률함수를 이용해 지금 얻은 데이터들을 통해 얻은 확률밀도함수의 높이를 모두 곱했을 때 최대가 되어야 한다는 것이다.

하지만, 학습과정이라는 것은 애초에는 학습이 덜 되어 있다는 뜻이므로 likelihood(즉, 모든 데이터들을 통해 얻은 확률밀도함수의 높이를 곱한 것)를 최대화 시켜주기 위해 Gradient ascent 방법을 이용할 수 있다. 그런데 보통은 어떤 모델을 학습할 때에는 경사**하강**을 시켜주기 때문에 likelihood에 -1을 곱해준 negative likelihood를 최소화 시켜주도록 하자. 그래서 우리는 [Gradient Descent 방법](https://angeloyeo.github.io/2020/08/16/gradient_descent.html)을 이용하도록 하자.

또, 보통은 likelihood를 직접이용하기 보다는 log-likelihood를 이용하는 것이 일반적이므로 negative log-likelihood를 최소화 시켜줄 수 있도록 식을 계산해보도록 하자.

RBM의 파라미터들을 $\theta$라고 통칭하도록 하자. 이제, 식 (8)로부터,

$$-\frac{\partial}{\partial \theta}\log p(v) = -\frac{\partial}{\partial\theta}\log\left(\frac{\exp(-F(v))}{Z}\right)$$

$$=-\frac{\partial}{\partial\theta}\left(\log\exp(-F(v)) - \log(Z)\right)$$

$$=-\frac{\partial}{\partial\theta}(-F(v)-log(Z))$$

$$=\frac{\partial}{\partial\theta}F(v) +\frac{\partial}{\partial\theta}\log(Z)$$

$$=\frac{\partial}{\partial\theta}F(v) + \frac{\partial}{\partial\theta}\log\left(\sum_{\tilde v} \exp(-F(\tilde v))\right)$$

여기서 $\tilde v$는 RBM 모델에 의해 생성된 visible unit들에 들어가는 샘플이다.

$$=\frac{\partial}{\partial\theta}F(v) +\frac{\sum_{\tilde v}\exp(-F(\tilde v))\frac{\partial}{\partial\theta}(-F(\tilde v))}{\sum_{\tilde v}\exp(-F(\tilde v))}$$


$$=\frac{\partial}{\partial\theta}F(v) -\sum_{\tilde v}\frac{\exp(-F(\tilde v))}{Z}\cdot\frac{\partial}{\partial\theta}(F(\tilde v))$$

$$=\frac{\partial}{\partial\theta}F(v) -\sum_{\tilde v}p(\tilde v)\frac{\partial}{\partial\theta}F(\tilde v)$$

$$=\frac{\partial}{\partial\theta}F(v)-E_p\left\lbrace\frac{\partial F(\tilde v)}{\partial \theta}\right\rbrace$$

$$\approx\frac{\partial}{\partial\theta}F(v) - \frac{1}{|\mathcal{N}|}\sum_{\tilde{v}\in\mathcal{N}}\frac{\partial F(\tilde{v})}{\partial\theta}$$


TODO: 위 식의 전개에 대해서 코멘트 달아줄 것.

TODO: 최종 식이 positive phase와 negative phase로 구성되어 있음을 설명할 것.

TODO: 위 최종 식의 의미는 loss와 같으며 결국 = $F(v) - F(\tilde v)$ 임을 설명하고 그 의미에 대해 서술할 것.

## 결국 RBM에게 학습이란: Contrastive Divergence를 줄이는 것

Contrastive Divergence(CD)란 visible layer에 데이터를 주고 hidden layer의 node 값을 샘플링, 그런 다음 다시 visible layer의 데이터를 다시 예측하도록 하는 과정에서 처음 주어진 visible layer의 데이터와 다시 획득한 visible layer의 데이터가 얼마나 차이가 있는지를 말하는 것.

만약 weight matrix와 hidden layer의 bias가 잘 학습되었다면 hidden unit을 잘 sample 해줄 수 있을 것이고 그렇다면 재획득한 visible layer의 데이터는 원래의 데이터와 일치할 것이기 때문이다.

즉, 원래의 데이터로부터 얻은 visible layer의 free energy와 생성된 데이터로부터 얻은 visible layer의 free energy 간의 차이가 적을 수록 학습이 잘 된 것이라고 할 수 있으므로 loss는 다음과 같이 생각할 수 있다.

$$loss = F(v)-F(v^{(1)})$$

### Sampling 과정

TODO: Gibbs sampling에 대해 설명.

Gibbs sampling은 [Markov Chain Monte Carlo](https://angeloyeo.github.io/2020/09/17/MCMC.html)의 한 방법으로 구분됨. Markov Chain의 특성을 이용해 sampling하는 것이기 때문에 RBM의 sampling을 Gibbs Sampling으로 볼 수 있다고 생각한 것으로 보임. 이름은 어렵고 현란해 보이지만 결국은 likelihood 비교를 통한 Accept/Reject에 불과한 것임.

TODO2: Gibbs sampling의 과정을 조금 더 구체적으로 설명. 실제로는 주어진 visible unit 혹은 hidden unit을 놓고 Rejection Sampling이 일어남을 설명

# RBM 의 학습 코드 (Python)

RBM의 학습 코드는 Python을 기반으로 했으며 Pytorch를 이용해 최적화하였다.

[Pytorch](https://pytorch.org/)로 포팅한 코드의 출처는 [이곳](https://github.com/odie2630463/Restricted-Boltzmann-Machines-in-pytorch)이며, 원래의 [Theano](http://www.deeplearning.net/software/theano/)를 이용해 포팅했던 소스코드는 [이곳](http://deeplearning.net/tutorial/rbm.html)이 참고 되었음을 밝힌다.

TODO: 글을 다 쓰고 가장 마지막에 학습 코드 붙일 것. HTML 코드 너무 길어... 최대한 주석을 달아줄 것.

# RBM 학습 결과

# 참고 자료

* [Introduction to Restricted Boltzmann Machine, Edwin Chen](http://blog.echen.me/2011/07/18/introduction-to-restricted-boltzmann-machines/)
* [Restricted Boltzmann Machine, DeepLearning 0.1 Documentation](http://deeplearning.net/tutorial/rbm.html)
* [What is the difference between autoencoders and a restricted Boltzmann machine?](https://www.quora.com/What-is-the-difference-between-autoencoders-and-a-restricted-Boltzmann-machine)
* [Ali Ghodsi, Lec [7], Deep Learning , Restricted Boltzmann Machines (RBMs)](https://www.youtube.com/watch?v=FJ0z3Ubagt4&ab_channel=DataScienceCourses)